## 1. Scope  

These rules apply to:

- All code written or modified by Cursor (apps, packages, tests, docs)  
- The entire monorepo structure (`apps/`, `packages/`)  
- Any Pull Request generated by Cursor

## 2. Rule Format  

Each rule is a statement beginning with a verb.  

Example: "Use functional components and hooks for React UI."

## 3. Rules  

### 3.1 Architecture & Structure  

- Use the monorepo layout: `apps/` for applications, `packages/` for shared libs.  
- In every module (app or package), use layered folders: `domain/`, `application/`, `infrastructure/`, `presentation/`, `app/`.  
- Do not mix domain logic with UI or infrastructure code.  
- Place shared utilities in `packages/utils/`, UI components in `packages/ui/`.  
- Use path aliases (e.g., `@app/`, `@core/`, `@ui/`) defined in `tsconfig.json`.

### 3.2 React & UI  

- Use functional components and hooks; do not use class components.  
- Call hooks only at the top level of a component.  
- Favour composition: break UI down into small reusable pieces.  
- Only optimise with `React.memo`, `useMemo`, `useCallback` when there is evidence of heavy renders.  
- Use semantic HTML, accessible props and ARIA roles where needed.

### 3.3 Next.js  

- Use the App Router pattern (`src/app/`, `layout.tsx`, `page.tsx`).  
- Keep pages thin: extract business logic into services/cases in `application/`.  
- For non-user-specific data use SSG/ISR; use SSR only when needed.  
- Use `<Image>` component for images; keep SEO metadata (title, description, OpenGraph) configured.  
- Never expose secrets on the client: store them in `.env.local`, etc.
- **Next.js 16+**: Route parameters (`params`) in API routes are now `Promise<{}>`. Always `await params` before accessing properties.
- **API Route Handlers**: Type params correctly as `{ params: Promise<{ id: string }> }` and destructure after awaiting: `const { id } = await params;`.

### 3.4 TypeScript  

- Enable strict mode: `strict: true`, `noImplicitReturns: true`, `noUnusedLocals: true`.  
- Avoid `any`; if unavoidable justify via comment.  
- Prefer `unknown` + type narrowing over `any`.  
- Export typed parameters and returns for every public function.  
- Reuse Prisma-generated types when appropriate.  
- For monorepo, use project references or path aliases to manage dependencies.

### 3.5 Tailwind CSS  

- Use a central `tailwind.config.js` per app, define design tokens (colors, typography, spacing).  
- Write mobile-first styles and use responsive breakpoints (e.g., `sm:`, `md:`) wisely.  
- For complex or repetitive class lists, use `@apply` to create reusable class names.  
- Keep global styles in `src/styles/globals.css`; local styles via CSS Modules when needed.  
- **All input fields (input, textarea, select) MUST include these classes**: `text-black` for text color and `placeholder:text-gray-400` for placeholder color to maintain consistency with the login form.

### 3.6 Prisma  

- Manage database changes only via `schema.prisma` + `prisma migrate`.  
- Use a singleton `PrismaClient` instance (handle dev vs production correctly).  
- Do not access Prisma inside UI or component layers; use repository abstractions in `infrastructure/`.  
- Use transactions (`prisma.$transaction`) for multi-step operations.  
- Use `select`/`include` to fetch only needed fields; paginate large datasets; create indexes for high-load fields.
- **Referential Integrity**: When creating/deleting records with related tables, ALWAYS use transactions to ensure data consistency.
- **Example**: When creating a `categoria`, also create its `categoria_config` in the same transaction.
- **Example**: When deleting a `categoria`, first delete related `categoria_config` records, then delete the categoria itself.
- Always disconnect Prisma client in service layer using `finally` block: `await prisma.$disconnect()`.

### 3.7 Testing (Jest + React Testing Library)  

- Write unit tests for pure functions, custom hooks, important services and React components.  
- Place tests next to code files (`*.test.ts`, `*.test.tsx`).  
- Use Arrange-Act-Assert pattern; name tests clearly (`describe`, `it/test`).  
- In React tests, use React Testing Library to test user interactions and visible outcomes rather than implementation details.  
- Mock external dependencies; include some integration tests for critical parts (DB, services).  
- Maintain decent coverage but don't aim for 100% at all costs—focus on value.
- **Framework Compatibility**: Keep tests updated with framework versions. For Next.js 16+ API route tests, mock params as Promises: `{ params: Promise.resolve({ id: '1' }) }`.
- **TypeScript Checking**: Run `npx tsc --noEmit` before committing to catch type errors that tests might reveal.
- **Test Before Deploy**: Always ensure tests pass locally before pushing to deployment platforms (Vercel, etc.).

### 3.8 Version Control & Breaking Changes

- When upgrading major framework versions (Next.js, React, etc.), review migration guides for breaking changes.
- Document breaking changes in commit messages with clear descriptions.
- Update all affected code paths (routes, components, tests) to match new API requirements.
- Run full test suite and build after major version upgrades before committing.
- Check for deprecated features and replace them proactively (e.g., Next.js middleware → proxy).

### 3.9 Documentation & Storybook  

- Each reusable UI component must have a Storybook story file (`*.stories.tsx`) demonstrating default state + variants.  
- Use MDX stories when additional documentation is needed.  
- Update stories when component changes.  
- Comment "why" (reasoning) not "what" in code.  
- Maintain README at repo root explaining the monorepo structure and how to run dev/build/test.  
- Keep docs/architecture.md (or similar) describing the Clean Architecture directory structure and decisions.

### 3.10 Deployment & Build (Vercel)

- Always test production builds locally with `npm run build` before pushing to main/deployment branches.
- Include `postinstall` script in `package.json` to run `prisma generate` for Vercel deployments.
- Monitor TypeScript errors in build: Vercel will fail on TS errors that might be ignored in dev mode.
- Use environment variables properly: configure them in Vercel dashboard and reference in `.env.example`.
- Test with the same Node version that Vercel uses (check `engines` in `package.json`).
- Never commit `.env` files; only commit `.env.example` with placeholder values.

### 3.11 Maintainability & Scalability  

- Domain layer must **not depend** on UI, Next.js or Prisma.  
- Use dependency injection: pass repositories/services as params instead of creating inside cases.  
- Divide large modules into bounded contexts (users, payments, catalog, etc.) with minimal coupling.  
- Always perform code review: check linting, architecture rules, tests passing.  
- Refactor gradually: apply the Boy Scout rule (leave code cleaner than found).  
- Keep dependencies up-to-date; remove unused packages.

### 3.12 Cursor Agent Behaviour  

- When Cursor generates code, it **must** follow all above rules.  
- When Cursor proposes refactors, it **must** maintain the directory structure and layering, and explain its decisions.  
- When Cursor creates documentation, it **must** update the README/docs accordingly.  
- When Cursor has a design decision ambiguity, it should choose simplicity, clarity, separation of concerns, and document the choice.
- Before marking a task as complete, Cursor must verify: TypeScript errors cleared, tests pass, build succeeds.

---

## ✅ Confirmation  

By saving this file, the Cursor agent should **automatically consume** these rules and adapt its behaviour accordingly.
