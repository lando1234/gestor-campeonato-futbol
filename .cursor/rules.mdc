# Cursor Rules â€“ Monorepo React/Next.js/TS/Tailwind/Prisma/Jest

## ðŸŽ¯ Purpose  

Define how the Cursor agent should generate, refactor and document code for this monorepo to ensure readability, maintainability and architecture consistency.

## 1. Scope  

These rules apply to:

- All code written or modified by Cursor (apps, packages, tests, docs)  
- The entire monorepo structure (`apps/`, `packages/`)  
- Any Pull Request generated by Cursor

## 2. Rule Format  

Each rule is a statement beginning with a verb.  

Example: "Use functional components and hooks for React UI."

## 3. Rules  

### 3.1 Architecture & Structure  

- Use the monorepo layout: `apps/` for applications, `packages/` for shared libs.  
- In every module (app or package), use layered folders: `domain/`, `application/`, `infrastructure/`, `presentation/`, `app/`.  
- Do not mix domain logic with UI or infrastructure code.  
- Place shared utilities in `packages/utils/`, UI components in `packages/ui/`.  
- Use path aliases (e.g., `@app/`, `@core/`, `@ui/`) defined in `tsconfig.json`.

### 3.2 React & UI  

- Use functional components and hooks; do not use class components.  
- Call hooks only at the top level of a component.  
- Favour composition: break UI down into small reusable pieces.  
- Only optimise with `React.memo`, `useMemo`, `useCallback` when there is evidence of heavy renders.  
- Use semantic HTML, accessible props and ARIA roles where needed.

### 3.3 Next.js  

- Use the App Router pattern (`src/app/`, `layout.tsx`, `page.tsx`).  
- Keep pages thin: extract business logic into services/cases in `application/`.  
- For non-user-specific data use SSG/ISR; use SSR only when needed.  
- Use `<Image>` component for images; keep SEO metadata (title, description, OpenGraph) configured.  
- Never expose secrets on the client: store them in `.env.local`, etc.

### 3.4 TypeScript  

- Enable strict mode: `strict: true`, `noImplicitReturns: true`, `noUnusedLocals: true`.  
- Avoid `any`; if unavoidable justify via comment.  
- Prefer `unknown` + type narrowing over `any`.  
- Export typed parameters and returns for every public function.  
- Reuse Prisma-generated types when appropriate.  
- For monorepo, use project references or path aliases to manage dependencies.

### 3.5 Tailwind CSS  

- Use a central `tailwind.config.js` per app, define design tokens (colors, typography, spacing).  
- Write mobile-first styles and use responsive breakpoints (e.g., `sm:`, `md:`) wisely.  
- For complex or repetitive class lists, use `@apply` to create reusable class names.  
- Keep global styles in `src/styles/globals.css`; local styles via CSS Modules when needed.  
- **All input fields (input, textarea, select) MUST include these classes**: `text-black` for text color and `placeholder:text-gray-400` for placeholder color to maintain consistency with the login form.

### 3.6 Prisma  

- Manage database changes only via `schema.prisma` + `prisma migrate`.  
- Use a singleton `PrismaClient` instance (handle dev vs production correctly).  
- Do not access Prisma inside UI or component layers; use repository abstractions in `infrastructure/`.  
- Use transactions (`prisma.$transaction`) for multi-step operations.  
- Use `select`/`include` to fetch only needed fields; paginate large datasets; create indexes for high-load fields.

### 3.7 Testing (Jest + React Testing Library)  

- Write unit tests for pure functions, custom hooks, important services and React components.  
- Place tests next to code files (`*.test.ts`, `*.test.tsx`).  
- Use Arrange-Act-Assert pattern; name tests clearly (`describe`, `it/test`).  
- In React tests, use React Testing Library to test user interactions and visible outcomes rather than implementation details.  
- Mock external dependencies; include some integration tests for critical parts (DB, services).  
- Maintain decent coverage but don't aim for 100% at all costsâ€”focus on value.

### 3.8 Documentation & Storybook  

- Each reusable UI component must have a Storybook story file (`*.stories.tsx`) demonstrating default state + variants.  
- Use MDX stories when additional documentation is needed.  
- Update stories when component changes.  
- Comment "why" (reasoning) not "what" in code.  
- Maintain README at repo root explaining the monorepo structure and how to run dev/build/test.  
- Keep docs/architecture.md (or similar) describing the Clean Architecture directory structure and decisions.

### 3.9 Maintainability & Scalability  

- Domain layer must **not depend** on UI, Next.js or Prisma.  
- Use dependency injection: pass repositories/services as params instead of creating inside cases.  
- Divide large modules into bounded contexts (users, payments, catalog, etc.) with minimal coupling.  
- Always perform code review: check linting, architecture rules, tests passing.  
- Refactor gradually: apply the Boy Scout rule (leave code cleaner than found).  
- Keep dependencies up-to-date; remove unused packages.

### 3.10 Cursor Agent Behaviour  

- When Cursor generates code, it **must** follow all above rules.  
- When Cursor proposes refactors, it **must** maintain the directory structure and layering, and explain its decisions.  
- When Cursor creates documentation, it **must** update the README/docs accordingly.  
- When Cursor has a design decision ambiguity, it should choose simplicity, clarity, separation of concerns, and document the choice.

---

## âœ… Confirmation  

By saving this file, the Cursor agent should **automatically consume** these rules and adapt its behaviour accordingly.
